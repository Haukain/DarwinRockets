<!DOCTYPE html>
<html>
<head>
	<title>
		Test Worker 
	</title>
	<!-- Title, Favicon and SEO Meta -->
	<title>DarwinRockets - Displayer Test</title>
	<meta name="description" content="Learning App to let you toy with the concept of darwinian evolution.">
	<meta name="author" content="Titouan Baillon, Timothy Cabaret, MaÃ¯wenn Berthelot, Adrien Constante, Lukas Chaillant">

	<link rel="apple-touch-icon" sizes="180x180" href="../../assets/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="../../assets/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="../../assets/icons/favicon-16x16.png">
	<link rel="manifest" href="../../assets/icons/site.webmanifest">
	<link rel="mask-icon" href="../../assets/icons/safari-pinned-tab.svg" color="#d65b73">
	<link rel="shortcut icon" href="../../assets/icons/favicon.ico">
	<meta name="msapplication-config" content="../../assets/icons/browserconfig.xml">
	<!-- Librairies -->
	<script src="../../libs/jquery/jquery-3.3.1.min.js"></script>
	<link rel="stylesheet" type="text/css" href="../../libs/bootstrap/css/bootstrap.min.css">
	<link rel="stylesheet" type="text/css" href="../../libs/bootstrap/css/bootstrap-reboot.min.css">
	<script src="../../libs/bootstrap/js/bootstrap.bundle.js"></script>
	<script src="../../libs/chartjs/Chart.bundle.min.js"></script>
	<script src="../../libs/matterjs/matter.min.js"></script>
	<link rel="stylesheet" type="text/css" href="../../libs/material-icons/material-icons.css">
</head>
<body>
	<script>
		// module aliases
		var Engine = Matter.Engine,
		    Render = Matter.Render,
		    World = Matter.World,
		    Bodies = Matter.Bodies;
		    Body = Matter.Body;
		    Constraint = Matter.Constraint;
		    Composite = Matter.Composite;
		    Events = Matter.Events;
        	Vertices = Matter.Vertices

		class PhysicsReactor{
		  constructor(blueprint,reactorRender,position,angle,thrust){
		    this._position = position;
		    this._angle = angle;
		    this._thrust = thrust;
		    this.active = false;
		    this._body = Body.create({
					vertices: blueprint,
					render: reactorRender,
		    });
		    this._body.label = "reactorBody";
				Body.scale(this._body,2000*this._thrust,2000*this._thrust);
				Body.setPosition(this._body,this._position);
				Body.setAngle(this._body, this._angle);
		  }
		  get position(){return this._position;}
		  get angle(){return this._angle;}
		  get thrust(){return this._thrust;}
		  get body(){return this._body;}
		  applyThrust(rocket){
		    if(!this.active){
		    	this._body.render.fillStyle =  '#d65b73'
		    	return
		    };
		    this._body.render.fillStyle = '#1a233a';
		    let thrustVector = {
		      x : Math.cos(this._angle+rocket.object.angle+Math.PI/2)*this._thrust,
		      y : Math.sin(this._angle+rocket.object.angle+Math.PI/2)*this._thrust
		    }
		    Body.applyForce(rocket.object,{x: this._body.position.x, y: this._body.position.y},thrustVector);
		  }
		}

		class PhysicsRocket{
		  constructor(blueprint,rocketRender,reactorRender,position,reactorDefinitions){
		    this._body = Body.create({
					vertices: rocketBluePrint,
					render: rocketRender,
		    });
		    this._body.label = "rocketBody";
				Body.setAngle(this._body, Math.PI);

		    this._reactors = [];
		    for(let rd of reactorDefinitions) this._reactors.push(new PhysicsReactor(blueprint,reactorRender,rd.position,rd.angle,rd.thrust));

		    this._object = Body.create({
		    	parts:[this._body].concat(this._reactors.map(d=>d.body)),
		    	friction: 0.1,
				frictionAir : 0.01,
				frictionStatic :0.03
		    });

			this._object.label = "rocket";
			Body.setPosition(this._object,position);

		    //manual controls
		    document.body.addEventListener("keydown",e=>{
		      if(e.keyCode-49>=0 && e.keyCode-49<9){
		      	if (this._reactors[e.keyCode-49]){
		      	this._reactors[e.keyCode-49].active = true;
		      	}
		      }
		    },false);
		    document.body.addEventListener("keyup",e=>{
		      if(e.keyCode-49>=0 && e.keyCode-49<9){
		      	if (this._reactors[e.keyCode-49]){
		      		this._reactors[e.keyCode-49].active = false;
		      	}
		      }
		    },false);

		  }

		  get body(){return this._body;}
		  get object(){return this._object;}

		  applyThrusts(){
		    for(let reactor of this._reactors){
		    	 reactor.applyThrust(this);
		    }
		  }

		}

		class PhysicObstacle{
			constructor(rocket,position,radius){
				if (new.target === PhysicObstacle) {
			      throw new TypeError("PhysicObstacle is an abstract class"); //Abstract error
			    }
				this._object = Bodies.circle(position.x,position.y,radius,{isStatic : true});
				this._rocket = rocket;
			}

			get object(){return this._object;}

			applyGravitation(){
				let distanceSquared = Math.pow(this._object.position.x - this._rocket.object.position.x,2) + Math.pow(this._object.position.y - this._rocket.object.position.y,2)
				let attractionForce = 0.0001*(this._object.mass*this._rocket.object.mass)/(distanceSquared);

				let beta = Math.atan2(this._object.position.y - this._rocket.object.position.y,this._object.position.x - this._rocket.object.position.x)
				Body.applyForce(this._rocket.object,{x:this._rocket.object.position.x,y:this._rocket.object.position.y},{x:Math.cos(beta)*attractionForce,y:Math.sin(beta)*attractionForce});
			}
		}

		class physicPlanet extends PhysicObstacle{
			constructor(rocket,position,radius){
				super(rocket,position,radius);
				Body.setDensity(this._object,0.07);
			}
		}

		class PhysicBlackhole extends PhysicObstacle{
			constructor(rocket,position,radius){
				super(rocket,position,radius);
				Body.setDensity(this._object,0.90);
				this._object.render.fillStyle ='#1a233a';
				this._object.render.strokeStyle ='invisible';
				this._object.render.lineWidth = 0.1 ;
			}
		}

		// Create an engine
		let engine = Engine.create();
		engine.world.gravity.y = 0;

		// Create a renderer
		let render = Render.create({element: document.body,engine: engine});
		render.options.wireframes = false;
		render.canvas.width = document.documentElement.clientWidth -100;
		render.canvas.height = document.documentElement.clientHeight -100;

		// Rocket parameters 
		let rocketInitialPosition = {x:document.documentElement.clientWidth/2,y:document.documentElement.clientHeight*2/3}
		// let rocketBluePrint = [{ x: 0, y: 0 },{ x: 30, y: 0 },{ x: 30, y: 40 },{ x: 25, y: 50 },{ x: 15, y: 55 },{ x: 5, y: 50 },{ x: 0, y: 40 }]; 
		let rocketBluePrint = Vertices.fromPath('-9 -20 -9 0 -7 15 -4 30 -3 33 -2 35 0 36 2 35 3 33 4 30 7 15 9 0 9 -20');
		let rocketRender = {
		         fillStyle: '#85bce6',
		         strokeStyle: 'invisible',
		         lineWidth: 0.2
		};
		let reactorRender = {
		         fillStyle: '#d65b73',
		         strokeStyle: 'invisible',
		         lineWidth: 0.2
		};

		// Create rocket parts
		
	    let rocket = new PhysicsRocket(rocketBluePrint,rocketRender,reactorRender,rocketInitialPosition,[
	      {position:{x:Math.random()*15-8,y:Math.random()*40 -10},angle:Math.random()*3-1.5+Math.PI,thrust:0.00015*(Math.random()+1)},
	      {position:{x:Math.random()*15-8,y:Math.random()*40 -10},angle:Math.random()*3-1.5+Math.PI,thrust:0.00015*(Math.random()+1)},
	      {position:{x:Math.random()*15-8,y:Math.random()*40 -10},angle:Math.random()*3-1.5+Math.PI,thrust:0.00015*(Math.random()+1)},
	      {position:{x:Math.random()*15-8,y:Math.random()*40 -10},angle:Math.random()*3-1.5+Math.PI,thrust:0.00015*(Math.random()+1)},
	    ]);

		// add the rocket to the world
		World.add(engine.world, [rocket.object]);

		// obstacle creation
		let obstacle = [];
		for(let i = 0; i<4; i++){
			obstacle.push(new physicPlanet(rocket,{x:Math.random()*1000+100,y:Math.random()*500+100},40));
		}
		obstacle.push(new PhysicBlackhole(rocket,{x:Math.random()*800 +400,y:Math.random()*300 +200},50));

		for(let o of obstacle){
			World.add(engine.world, o.object);
		}


		// check for collisions
		Matter.Events.on(engine, 'collisionActive', function(event) {
			let i, currentPair, currentPart;
			let n = event.pairs.length;
			let m = rocket.object.parts.length

			for(let i =0; i<n; i++){
				currentPair = event.pairs[i];
				for(let j=0;j<m;j++){
					currentPart = rocket.object.parts[j];
					if( (currentPair.bodyA.label === currentPart.label) || (currentPair.bodyB.label === currentPart.label)){
						console.log("collision");
					}
				}

			}

		});

		// apply force
		Events.on(engine, "beforeUpdate",e=>{
      		rocket.applyThrusts();
      		for(o of obstacle){
      			o.applyGravitation();
      		}
		})

		// run the engine
		Engine.run(engine);

		// run the renderer
		Render.run(render);

	</script>
</body>
</html>
